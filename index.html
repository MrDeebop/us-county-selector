<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>U.S. County Selection Tool - Shapefile Upload</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.7.1/dist/leaflet.css" />
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            line-height: 1.6;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        .upload-section {
            background: #f5f5f5;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
        }
        .map-container {
            height: 600px;
            border: 1px solid #ddd;
            border-radius: 8px;
            margin-top: 20px;
        }
        .instructions {
            background: #e7f4ff;
            padding: 15px;
            border-left: 4px solid #3498db;
            margin-bottom: 20px;
            border-radius: 4px;
        }
        button {
            background: #3498db;
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
        }
        button:hover {
            background: #2980b9;
        }
        .error {
            color: #e74c3c;
            margin-top: 10px;
        }
        .success {
            color: #27ae60;
            margin-top: 10px;
        }
        .file-input-wrapper {
            margin: 15px 0;
        }
        .loading {
            display: none;
            margin: 10px 0;
        }
        .loading.active {
            display: block;
        }
        .file-list {
            margin: 10px 0;
            padding: 0;
            list-style: none;
        }
        .file-list li {
            padding: 5px 0;
            border-bottom: 1px solid #eee;
        }
        #drop-zone {
            border: 2px dashed #ccc;
            padding: 20px;
            text-align: center;
            margin: 10px 0;
            border-radius: 8px;
        }
        #drop-zone.active {
            border-color: #3498db;
            background-color: #f0f8ff;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>U.S. County Selection Tool - Shapefile Upload</h1>
        
        <div class="instructions">
            <h3>Instructions:</h3>
            <ol>
                <li>Obtain a U.S. county shapefile from the <a href="https://www.census.gov/geographies/mapping-files/time-series/geo/carto-boundary-file.html" target="_blank">U.S. Census Bureau</a></li>
                <li>Extract the entire shapefile folder (should contain .shp, .shx, .dbf at minimum)</li>
                <li>Drag and drop the entire folder or select all files below</li>
                <li>Interact with the map to select counties</li>
            </ol>
            <p><strong>Note:</strong> Processing time depends on file size (see estimates below).</p>
        </div>
        
        <div class="upload-section">
            <h2>Upload Your Shapefile</h2>
            <div id="drop-zone">
                <p>Drag and drop your entire shapefile folder here</p>
                <p>or</p>
                <div class="file-input-wrapper">
                    <input type="file" id="shapefile-upload" multiple webkitdirectory directory>
                </div>
            </div>
            <button id="upload-btn">Process Shapefile</button>
            <div id="loading" class="loading">
                <p id="loading-text">Processing files...</p>
                <div id="progress-bar" style="width: 100%; background: #ddd; height: 20px; margin-top: 10px;">
                    <div id="progress" style="width: 0%; height: 100%; background: #3498db;"></div>
                </div>
            </div>
            <div id="file-list-container" style="display: none;">
                <h4>Files detected:</h4>
                <ul class="file-list" id="file-list"></ul>
            </div>
            <div id="time-estimate" style="margin-top: 10px;"></div>
            <div id="message"></div>
        </div>
        
        <div class="map-container" id="map"></div>
        
        <div id="selection-info" style="margin-top: 20px;"></div>
    </div>

    <script src="https://unpkg.com/leaflet@1.7.1/dist/leaflet.js"></script>
    <script src="https://unpkg.com/shpjs@4.0.2/dist/shp.js"></script>
    <script>
        // Initialize map
        const map = L.map('map').setView([39.8283, -98.5795], 4);
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
        }).addTo(map);

        // UI elements
        const fileInput = document.getElementById('shapefile-upload');
        const uploadBtn = document.getElementById('upload-btn');
        const messageDiv = document.getElementById('message');
        const loadingDiv = document.getElementById('loading');
        const loadingText = document.getElementById('loading-text');
        const progressBar = document.getElementById('progress');
        const selectionInfo = document.getElementById('selection-info');
        const dropZone = document.getElementById('drop-zone');
        const fileListContainer = document.getElementById('file-list-container');
        const fileList = document.getElementById('file-list');
        const timeEstimate = document.getElementById('time-estimate');
        
        let geoJsonLayer = null;
        let selectedCounties = [];
        let shapefileFiles = [];

        // Set up drag and drop
        dropZone.addEventListener('dragover', (e) => {
            e.preventDefault();
            dropZone.classList.add('active');
        });

        dropZone.addEventListener('dragleave', () => {
            dropZone.classList.remove('active');
        });

        dropZone.addEventListener('drop', (e) => {
            e.preventDefault();
            dropZone.classList.remove('active');
            
            const items = e.dataTransfer.items;
            const files = [];
            
            // Handle directory drop
            for (let i = 0; i < items.length; i++) {
                const item = items[i].webkitGetAsEntry();
                if (item) {
                    traverseFileTree(item, files);
                }
            }
            
            // Handle direct file drop
            if (files.length === 0 && e.dataTransfer.files.length > 0) {
                Array.from(e.dataTransfer.files).forEach(file => {
                    files.push(file);
                });
            }
            
            handleFiles(files);
        });

        // Helper function to traverse directory structure
        function traverseFileTree(item, files, path = '') {
            if (item.isFile) {
                item.file((file) => {
                    file.filepath = path + file.name; // preserve relative path
                    files.push(file);
                });
            } else if (item.isDirectory) {
                const dirReader = item.createReader();
                dirReader.readEntries((entries) => {
                    for (let i = 0; i < entries.length; i++) {
                        traverseFileTree(entries[i], files, path + item.name + '/');
                    }
                });
            }
        }

        // Handle file input change
        fileInput.addEventListener('change', (e) => {
            handleFiles(Array.from(e.target.files));
        });

        // Process the files
        function handleFiles(files) {
            shapefileFiles = files.filter(file => {
                const ext = file.name.split('.').pop().toLowerCase();
                return ['.shp', '.shx', '.dbf', '.prj', '.cpg', '.xml'].includes('.' + ext);
            });
            
            if (shapefileFiles.length === 0) {
                showMessage('No valid shapefile components found. Please include .shp, .shx, and .dbf at minimum.', 'error');
                return;
            }
            
            // Display file list
            fileList.innerHTML = '';
            shapefileFiles.forEach(file => {
                const li = document.createElement('li');
                li.textContent = file.name + ` (${formatFileSize(file.size)})`;
                fileList.appendChild(li);
            });
            fileListContainer.style.display = 'block';
            
            // Calculate and show time estimate
            const totalSize = shapefileFiles.reduce((sum, file) => sum + file.size, 0);
            showTimeEstimate(totalSize);
        }

        // Format file size
        function formatFileSize(bytes) {
            if (bytes === 0) return '0 Bytes';
            const k = 1024;
            const sizes = ['Bytes', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
        }

        // Show time estimate based on file size
        function showTimeEstimate(totalSize) {
            // Rough estimates based on testing:
            // - 1MB ~ 1-2 seconds
            // - 10MB ~ 5-10 seconds
            // - 50MB ~ 20-40 seconds
            // - 100MB ~ 40-80 seconds
            
            const sizeMB = totalSize / (1024 * 1024);
            let estimate;
            
            if (sizeMB < 1) {
                estimate = '1-3 seconds';
            } else if (sizeMB < 5) {
                estimate = '3-8 seconds';
            } else if (sizeMB < 20) {
                estimate = '8-20 seconds';
            } else if (sizeMB < 50) {
                estimate = '20-40 seconds';
            } else if (sizeMB < 100) {
                estimate = '40-80 seconds';
            } else {
                estimate = '1-3 minutes';
            }
            
            timeEstimate.innerHTML = `<strong>Estimated processing time:</strong> ${estimate} (for ${formatFileSize(totalSize)})`;
        }

        // Handle upload button click
        uploadBtn.addEventListener('click', async function() {
            if (shapefileFiles.length === 0) {
                showMessage('Please select shapefile files first.', 'error');
                return;
            }
            
            // Find the .shp file
            const shpFile = shapefileFiles.find(f => f.name.toLowerCase().endsWith('.shp'));
            if (!shpFile) {
                showMessage('Could not find .shp file in selection.', 'error');
                return;
            }
            
            loadingDiv.classList.add('active');
            loadingText.textContent = 'Processing files...';
            progressBar.style.width = '0%';
            messageDiv.textContent = '';
            
            try {
                // Create a virtual file structure for shapefile.js
                const virtualFiles = {};
                shapefileFiles.forEach(file => {
                    virtualFiles[file.name] = file;
                });
                
                // Process with shapefile.js
                const geojson = await processShapefile(shpFile, virtualFiles);
                
                // Clear previous layer if exists
                if (geoJsonLayer) {
                    map.removeLayer(geoJsonLayer);
                    selectedCounties = [];
                    updateSelectionInfo();
                }
                
                // Process the converted GeoJSON
                processGeoJSON(geojson);
                
                showMessage('Shapefile successfully loaded and displayed.', 'success');
            } catch (error) {
                showMessage(`Error processing shapefile: ${error.message}`, 'error');
                console.error(error);
            } finally {
                loadingDiv.classList.remove('active');
            }
        });

        // Process shapefile with progress updates
        async function processShapefile(shpFile, virtualFiles) {
            return new Promise((resolve, reject) => {
                // Create file readers
                const readers = {};
                for (const filename in virtualFiles) {
                    readers[filename] = new FileReader();
                }
                
                // Read the .shp file first
                readers[shpFile.name].onload = function(e) {
                    const shpBuffer = e.target.result;
                    
                    // Find and read the .dbf file
                    const dbfFilename = shpFile.name.replace(/\.shp$/i, '.dbf');
                    const dbfFile = virtualFiles[dbfFilename];
                    
                    if (!dbfFile) {
                        reject(new Error(`Could not find matching .dbf file (looking for ${dbfFilename})`));
                        return;
                    }
                    
                    readers[dbfFilename].onload = function(e) {
                        const dbfBuffer = e.target.result;
                        
                        // Optional: read .prj file if exists
                        const prjFilename = shpFile.name.replace(/\.shp$/i, '.prj');
                        const prjFile = virtualFiles[prjFilename];
                        
                        if (prjFile) {
                            readers[prjFilename].onload = function(e) {
                                const prjText = e.target.result;
                                processData(shpBuffer, dbfBuffer, prjText);
                            };
                            readers[prjFilename].readAsText(prjFile);
                        } else {
                            processData(shpBuffer, dbfBuffer);
                        }
                    };
                    
                    readers[dbfFilename].readAsArrayBuffer(dbfFile);
                };
                
                readers[shpFile.name].readAsArrayBuffer(shpFile);
                
                function processData(shpBuffer, dbfBuffer, prjText) {
                    try {
                        // Use shapefile.js to parse
                        const geojson = shp.combine([
                            shp.parseShp(shpBuffer, prjText),
                            shp.parseDbf(dbfBuffer)
                        ]);
                        
                        resolve(geojson);
                    } catch (error) {
                        reject(error);
                    }
                }
                
                // Update progress
                let filesProcessed = 0;
                const totalFiles = Object.keys(readers).length;
                
                for (const filename in readers) {
                    readers[filename].onloadend = function() {
                        filesProcessed++;
                        const progress = (filesProcessed / totalFiles) * 100;
                        progressBar.style.width = `${progress}%`;
                        loadingText.textContent = `Processing files... (${filesProcessed}/${totalFiles})`;
                    };
                }
            });
        }
        
        // The rest of your existing GeoJSON processing code remains the same
        function processGeoJSON(geojsonData) {
            // Style function for the GeoJSON
            function style(feature) {
                return {
                    fillColor: '#3388ff',
                    weight: 1,
                    opacity: 1,
                    color: 'white',
                    dashArray: '3',
                    fillOpacity: 0.7
                };
            }
            
            // Highlight feature on hover
            function highlightFeature(e) {
                const layer = e.target;
                
                layer.setStyle({
                    weight: 3,
                    color: '#666',
                    dashArray: '',
                    fillOpacity: 0.7
                });
                
                layer.bringToFront();
                
                // Show county name in info panel
                const countyName = layer.feature.properties.NAME || layer.feature.properties.name || 'Unnamed County';
                selectionInfo.innerHTML = `<strong>Hovering:</strong> ${countyName}`;
            }
            
            function resetHighlight(e) {
                geoJsonLayer.resetStyle(e.target);
                selectionInfo.textContent = '';
            }
            
            function onEachFeature(feature, layer) {
                // Get county name from properties
                const countyName = feature.properties.NAME || feature.properties.name || 'Unnamed County';
                const stateName = feature.properties.STATE_NAME || feature.properties.state_name || 'Unknown State';
                
                // Bind tooltip
                layer.bindTooltip(`${countyName}, ${stateName}`);
                
                // Add click event
                layer.on({
                    click: function(e) {
                        const layer = e.target;
                        
                        // Toggle selection
                        if (selectedCounties.includes(layer.feature)) {
                            // Deselect
                            selectedCounties = selectedCounties.filter(f => f !== layer.feature);
                            layer.setStyle({
                                fillColor: '#3388ff',
                                weight: 1
                            });
                        } else {
                            // Select
                            selectedCounties.push(layer.feature);
                            layer.setStyle({
                                fillColor: '#e74c3c',
                                weight: 2
                            });
                        }
                        
                        updateSelectionInfo();
                    },
                    mouseover: highlightFeature,
                    mouseout: resetHighlight
                });
            }
            
            // Create GeoJSON layer
            geoJsonLayer = L.geoJSON(geojsonData, {
                style: style,
                onEachFeature: onEachFeature
            }).addTo(map);
            
            // Fit map to the GeoJSON bounds
            map.fitBounds(geoJsonLayer.getBounds());
        }
        
        function updateSelectionInfo() {
            if (selectedCounties.length === 0) {
                selectionInfo.innerHTML = '<strong>No counties selected</strong>';
                return;
            }
            
            let html = `<strong>Selected Counties (${selectedCounties.length}):</strong><ul>`;
            
            selectedCounties.forEach(feature => {
                const countyName = feature.properties.NAME || feature.properties.name || 'Unnamed County';
                const stateName = feature.properties.STATE_NAME || feature.properties.state_name || 'Unknown State';
                html += `<li>${countyName}, ${stateName}</li>`;
            });
            
            html += '</ul>';
            selectionInfo.innerHTML = html;
        }
        
        function showMessage(text, type) {
            messageDiv.textContent = text;
            messageDiv.className = type;
        }
    </script>
</body>
</html>
